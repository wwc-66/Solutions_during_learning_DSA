'''
2:分发糖果
总时间限制: 500ms 内存限制: 65536kB
描述
老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。


你需要按照以下要求，帮助老师给这些孩子分发糖果：

1.每个孩子至少分配到 1 个糖果。

2.相邻的孩子中，评分高的孩子必须获得更多的糖果。

那么这样下来，老师至少需要准备多少颗糖果呢？

示例代码模板：

def candy(ratings):
    # code here
    pass

lst = eval(input())
print(candy(lst))

输入
一个列表，以文本格式的有效Python表达式给出
输出
一行数字，表示满足分配条件所需的最少糖果数
样例输入
[1,2,2]
样例输出
4
提示
注：可行的分配方案为1、2、1 颗糖果；第三个孩子只得到1颗糖果也满足题目条件
'''

def candy(ratings):
    n = len(ratings)
    if n == 0:
        return 0
    #初始值为全为1的列表，因为每个孩子都需要至少一颗糖果
    candies = [1] * n
    #从左到右遍历
    for i in range(1, n):
        #如果当前的孩子评分比他的前一位高
        if ratings[i] > ratings[i - 1]:
            #取当前孩子糖果个数和与之相比的孩子糖果个数的较大值
            candies[i] = max(candies[i],candies[i - 1]+1)
            #此处也可以直接取较小者的糖果数+1，因为在此轮遍历中，较小者糖果个数都为1

    #从右到左遍历
    for j in range(n-2, -1,-1):
        #如果当前的孩子评分比他的后一位高
        if ratings[j] > ratings[j + 1]:
            #取当前孩子糖果个数和与之相比的孩子糖果个数的较大值
            candies[j] = max(candies[j],candies[j + 1]+1)
    return sum(candies)

lst = eval(input())
print(candy(lst))

'''
两个方向分别遍历，
是为了防止评分次高的孩子糖果个数为1时，
其后一位评分更低的孩子糖果个数无法变得更低，
导致他们糖果个数相同，
不符合题目要求。

如，[1,3,2,2,1]，
初始糖果个数都为1，
而3 > 1使3分孩子的糖果个数为2，
而后面2分的孩子糖果个数只能为1，
但最后还有一个1分的孩子，
因此再反向遍历一次，
确保每个孩子都有糖果，
并且个数符合题目要求。
'''